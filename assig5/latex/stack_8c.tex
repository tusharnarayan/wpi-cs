\section{stack.c File Reference}
\label{stack_8c}\index{stack.c@{stack.c}}
{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include \char`\"{}stack.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
\bf{Stack} $\ast$ \bf{create\_\-stack} (int max\_\-cells)
\item 
void \bf{delete\_\-stack} (\bf{Stack} $\ast$which\_\-stack)
\item 
int \bf{push} (\bf{Stack} $\ast$which\_\-stack, void $\ast$ptr)
\item 
void $\ast$ \bf{pop} (\bf{Stack} $\ast$which\_\-stack)
\item 
void $\ast$ \bf{peek} (\bf{Stack} $\ast$which\_\-stack)
\end{CompactItemize}


\subsection{Function Documentation}
\index{stack.c@{stack.c}!create_stack@{create\_\-stack}}
\index{create_stack@{create\_\-stack}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\bf{Stack}$\ast$ create\_\-stack (int {\em max\_\-cells})}\label{stack_8c_f3af8ef3ef58b09c15cca16fd5e09907}


Create a stack by allocating a Stack structure, initializing it, and allocating memory to hold the stack entries. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em max\_\-cells}]Maximum entries in the stack \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to newly-allocated Stack structure, NULL if error. \end{Desc}
\index{stack.c@{stack.c}!delete_stack@{delete\_\-stack}}
\index{delete_stack@{delete\_\-stack}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void delete\_\-stack (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8c_f3285173a95add78b1910a3267378ed6}


Deletes a stack, including the structure and the memory for holding the stack entries, but not the entries themselves. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack structure that has to be deleted. \end{description}
\end{Desc}
\index{stack.c@{stack.c}!peek@{peek}}
\index{peek@{peek}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ peek (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8c_e6d178d94e76c529952cc01831026670}


Peek at top of stack, without popping \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack you want to peek into \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Top entry of the stack, NULL if stack is empty. \end{Desc}
\index{stack.c@{stack.c}!pop@{pop}}
\index{pop@{pop}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ pop (\bf{Stack} $\ast$ {\em which\_\-stack})}\label{stack_8c_306d7b021c4174d96da78af2105c066b}


Pops top of stack, and returns it. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to Stack you want to pop from. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Top entry of the stack, NULL if stack is empty. \end{Desc}
\index{stack.c@{stack.c}!push@{push}}
\index{push@{push}!stack.c@{stack.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int push (\bf{Stack} $\ast$ {\em which\_\-stack}, void $\ast$ {\em ptr})}\label{stack_8c_8dc04abc21a21e589ab50c53d14085cc}


Pushes a pointer onto a Stack. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em which\_\-stack}]Pointer to stack you want to push onto. \item[{\em ptr}]Pointer to be pushed. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]0 if successful, -1 if not. \end{Desc}
